/*
 * Infobip Client API Libraries OpenAPI Specification
 * OpenAPI specification containing public endpoints supported in client API libraries.
 *
 * Contact: support@infobip.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */


using System;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json.Serialization;
using Newtonsoft.Json;

namespace Infobip.Api.Client.Model
{
    /// <summary>
    ///     NumberMaskingSetupResponse
    /// </summary>
    [DataContract(Name = "NumberMaskingSetupResponse")]
    [JsonObject]
    public class NumberMaskingSetupResponse : IEquatable<NumberMaskingSetupResponse>
    {
        private DateTimeOffset _InsertDateTime;

        private DateTimeOffset _UpdateDateTime;

        /// <summary>
        ///     Initializes a new instance of the <see cref="NumberMaskingSetupResponse" /> class.
        /// </summary>
        /// <param name="key">Use to connect masking configuration with Voice-enabled number..</param>
        /// <param name="name">Unique configuration name. Alphanumeric, max length 100..</param>
        /// <param name="callbackUrl">
        ///     Client&#39;s URL that will be called on each inbound call to related Number masking Voice
        ///     number in order to get instructions of how to handle incoming calls. Instructions are a result of mapping logic
        ///     implemented on your side according to your business case..
        /// </param>
        /// <param name="statusUrl">Client&#39;s URL for status report delivery after the call is finished..</param>
        /// <param name="backupCallbackUrl">If callbackUrl is unavailable this one will be called instead..</param>
        /// <param name="backupStatusUrl">If statusUrl is unavailable this one will be called instead..</param>
        /// <param name="description">Masking configuration description.</param>
        /// <param name="insertDateTime">Date and time (UTC timezone) when masking configuration is created..</param>
        /// <param name="updateDateTime">Date and time (UTC timezone) when masking configuration was last modified..</param>
        public NumberMaskingSetupResponse(string key = default, string name = default, string callbackUrl = default,
            string statusUrl = default, string backupCallbackUrl = default, string backupStatusUrl = default,
            string description = default, DateTimeOffset insertDateTime = default,
            DateTimeOffset updateDateTime = default)
        {
            Key = key;
            Name = name;
            CallbackUrl = callbackUrl;
            StatusUrl = statusUrl;
            BackupCallbackUrl = backupCallbackUrl;
            BackupStatusUrl = backupStatusUrl;
            Description = description;
            InsertDateTime = insertDateTime;
            UpdateDateTime = updateDateTime;
        }

        /// <summary>
        ///     Use to connect masking configuration with Voice-enabled number.
        /// </summary>
        /// <value>Use to connect masking configuration with Voice-enabled number.</value>
        [DataMember(Name = "key", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "key", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("key")]
        public string Key { get; set; }

        /// <summary>
        ///     Unique configuration name. Alphanumeric, max length 100.
        /// </summary>
        /// <value>Unique configuration name. Alphanumeric, max length 100.</value>
        [DataMember(Name = "name", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "name", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        ///     Client&#39;s URL that will be called on each inbound call to related Number masking Voice number in order to get
        ///     instructions of how to handle incoming calls. Instructions are a result of mapping logic implemented on your side
        ///     according to your business case.
        /// </summary>
        /// <value>
        ///     Client&#39;s URL that will be called on each inbound call to related Number masking Voice number in order to get
        ///     instructions of how to handle incoming calls. Instructions are a result of mapping logic implemented on your side
        ///     according to your business case.
        /// </value>
        [DataMember(Name = "callbackUrl", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "callbackUrl", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("callbackUrl")]
        public string CallbackUrl { get; set; }

        /// <summary>
        ///     Client&#39;s URL for status report delivery after the call is finished.
        /// </summary>
        /// <value>Client&#39;s URL for status report delivery after the call is finished.</value>
        [DataMember(Name = "statusUrl", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "statusUrl", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("statusUrl")]
        public string StatusUrl { get; set; }

        /// <summary>
        ///     If callbackUrl is unavailable this one will be called instead.
        /// </summary>
        /// <value>If callbackUrl is unavailable this one will be called instead.</value>
        [DataMember(Name = "backupCallbackUrl", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "backupCallbackUrl", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("backupCallbackUrl")]
        public string BackupCallbackUrl { get; set; }

        /// <summary>
        ///     If statusUrl is unavailable this one will be called instead.
        /// </summary>
        /// <value>If statusUrl is unavailable this one will be called instead.</value>
        [DataMember(Name = "backupStatusUrl", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "backupStatusUrl", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("backupStatusUrl")]
        public string BackupStatusUrl { get; set; }

        /// <summary>
        ///     Masking configuration description
        /// </summary>
        /// <value>Masking configuration description</value>
        [DataMember(Name = "description", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "description", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        ///     Date and time (UTC timezone) when masking configuration is created.
        /// </summary>
        /// <value>Date and time (UTC timezone) when masking configuration is created.</value>
        [DataMember(Name = "insertDateTime", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "insertDateTime", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("insertDateTime")]
        [System.Text.Json.Serialization.JsonConverter(typeof(DateTimeOffsetConverter))]
        public DateTimeOffset InsertDateTime
        {
            get => _InsertDateTime;
            set => _InsertDateTime = new DateTimeOffset(value.DateTime, TimeSpan.Zero);
        }

        /// <summary>
        ///     Date and time (UTC timezone) when masking configuration was last modified.
        /// </summary>
        /// <value>Date and time (UTC timezone) when masking configuration was last modified.</value>
        [DataMember(Name = "updateDateTime", EmitDefaultValue = false)]
        [JsonProperty(PropertyName = "updateDateTime", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [JsonPropertyName("updateDateTime")]
        [System.Text.Json.Serialization.JsonConverter(typeof(DateTimeOffsetConverter))]
        public DateTimeOffset UpdateDateTime
        {
            get => _UpdateDateTime;
            set => _UpdateDateTime = new DateTimeOffset(value.DateTime, TimeSpan.Zero);
        }

        /// <summary>
        ///     Returns true if NumberMaskingSetupResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of NumberMaskingSetupResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(NumberMaskingSetupResponse input)
        {
            if (input == null)
                return false;

            return
                (
                    Key == input.Key ||
                    (Key != null &&
                     Key.Equals(input.Key))
                ) &&
                (
                    Name == input.Name ||
                    (Name != null &&
                     Name.Equals(input.Name))
                ) &&
                (
                    CallbackUrl == input.CallbackUrl ||
                    (CallbackUrl != null &&
                     CallbackUrl.Equals(input.CallbackUrl))
                ) &&
                (
                    StatusUrl == input.StatusUrl ||
                    (StatusUrl != null &&
                     StatusUrl.Equals(input.StatusUrl))
                ) &&
                (
                    BackupCallbackUrl == input.BackupCallbackUrl ||
                    (BackupCallbackUrl != null &&
                     BackupCallbackUrl.Equals(input.BackupCallbackUrl))
                ) &&
                (
                    BackupStatusUrl == input.BackupStatusUrl ||
                    (BackupStatusUrl != null &&
                     BackupStatusUrl.Equals(input.BackupStatusUrl))
                ) &&
                (
                    Description == input.Description ||
                    (Description != null &&
                     Description.Equals(input.Description))
                ) &&
                (
                    InsertDateTime == input.InsertDateTime ||
                    (InsertDateTime != null &&
                     InsertDateTime.Equals(input.InsertDateTime))
                ) &&
                (
                    UpdateDateTime == input.UpdateDateTime ||
                    (UpdateDateTime != null &&
                     UpdateDateTime.Equals(input.UpdateDateTime))
                );
        }

        /// <summary>
        ///     Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class NumberMaskingSetupResponse {\n");
            sb.Append("  Key: ").Append(Key).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  CallbackUrl: ").Append(CallbackUrl).Append("\n");
            sb.Append("  StatusUrl: ").Append(StatusUrl).Append("\n");
            sb.Append("  BackupCallbackUrl: ").Append(BackupCallbackUrl).Append("\n");
            sb.Append("  BackupStatusUrl: ").Append(BackupStatusUrl).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  InsertDateTime: ").Append(InsertDateTime).Append("\n");
            sb.Append("  UpdateDateTime: ").Append(UpdateDateTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        ///     Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        ///     Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return Equals(input as NumberMaskingSetupResponse);
        }

        /// <summary>
        ///     Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                if (Key != null)
                    hashCode = hashCode * 59 + Key.GetHashCode();
                if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                if (CallbackUrl != null)
                    hashCode = hashCode * 59 + CallbackUrl.GetHashCode();
                if (StatusUrl != null)
                    hashCode = hashCode * 59 + StatusUrl.GetHashCode();
                if (BackupCallbackUrl != null)
                    hashCode = hashCode * 59 + BackupCallbackUrl.GetHashCode();
                if (BackupStatusUrl != null)
                    hashCode = hashCode * 59 + BackupStatusUrl.GetHashCode();
                if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                if (InsertDateTime != null)
                    hashCode = hashCode * 59 + InsertDateTime.GetHashCode();
                if (UpdateDateTime != null)
                    hashCode = hashCode * 59 + UpdateDateTime.GetHashCode();
                return hashCode;
            }
        }
    }
}