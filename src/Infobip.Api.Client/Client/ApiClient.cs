/*
 * Infobip Client API Libraries OpenAPI Specification
 * OpenAPI specification containing public endpoints supported in client API libraries.
 *
 * Contact: support@infobip.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */


using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Infobip.Api.Client.Client;
using Infobip.Api.Client.Model;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Polly;

namespace Infobip.Api.Client
{
    /// <summary>
    ///     To Serialize/Deserialize JSON using our custom logic, but only when ContentType is JSON.
    /// </summary>
    internal class CustomJsonCodec
    {
        private static readonly string _contentType = "application/json";
        private readonly IReadableConfiguration _configuration;

        private readonly JsonSerializerSettings _serializerSettings = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            },
            DateFormatString = "yyyy-MM-ddTHH:mm:ss.fffzzzz"
        };

        public CustomJsonCodec(IReadableConfiguration configuration)
        {
            _configuration = configuration;
        }

        public CustomJsonCodec(JsonSerializerSettings serializerSettings, IReadableConfiguration configuration)
        {
            _serializerSettings = serializerSettings;
            _configuration = configuration;
        }

        public string ContentType
        {
            get => _contentType;
            set => throw new InvalidOperationException("Not allowed to set content type.");
        }

        public string DateFormat { get; set; }

        public string Namespace { get; set; }

        public string RootElement { get; set; }

        /// <summary>
        ///     Serialize the object into a JSON string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>A JSON string.</returns>
        public string Serialize(object obj)
        {
            if (obj != null && obj is AbstractOpenAPISchema)
                // the object to be serialized is an oneOf/anyOf schema
                return ((AbstractOpenAPISchema)obj).ToJson();
            return JsonConvert.SerializeObject(obj, _serializerSettings);
        }

        internal async Task<T> DeserializeAsync<T>(HttpResponseMessage response)
        {
            var result = (T)await DeserializeAsync(response, typeof(T)).ConfigureAwait(false);
            return result;
        }

        /// <summary>
        ///     Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="response">The HTTP response.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal async Task<object> DeserializeAsync(HttpResponseMessage response, Type type)
        {
            var headers = response.Headers.Select(x => x.Key + "=" + x.Value).ToList();

            if (type == typeof(byte[])) // return byte Array
                return await response.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
            if (type == typeof(FileParameter))
                return new FileParameter(await response.Content.ReadAsStreamAsync());

            // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
            if (type == typeof(Stream))
            {
                var bytes = await response.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
                if (headers != null)
                {
                    var filePath = string.IsNullOrEmpty(_configuration.TempFolderPath)
                        ? Path.GetTempPath()
                        : _configuration.TempFolderPath;
                    var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");
                    foreach (var header in headers)
                    {
                        var match = regex.Match(header);
                        if (match.Success)
                        {
                            var fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value
                                .Replace("\"", string.Empty).Replace("'", string.Empty));
                            File.WriteAllBytes(fileName, bytes);
                            return new FileStream(fileName, FileMode.Open);
                        }
                    }
                }

                return new MemoryStream(bytes);
            }

            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
                return DateTime.Parse(await response.Content.ReadAsStringAsync().ConfigureAwait(false), null,
                    DateTimeStyles.RoundtripKind);

            if (type == typeof(string) || type.Name.StartsWith("System.Nullable")) // return primitive type
                return Convert.ChangeType(await response.Content.ReadAsStringAsync().ConfigureAwait(false), type);

            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(await response.Content.ReadAsStringAsync().ConfigureAwait(false),
                    type, _serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }
    }

    /// <summary>
    ///     Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
    ///     encapsulating general REST accessor use cases.
    /// </summary>
    /// <remarks>
    ///     The Dispose method will manage the HttpClient lifecycle when not passed by constructor.
    /// </remarks>
    public class ApiClient : IDisposable, ISynchronousClient, IAsynchronousClient
    {
        private readonly string _baseUrl;
        private readonly bool _disposeClient;
        private readonly HttpClient _httpClient;
        private readonly HttpClientHandler _httpClientHandler;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" />.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        public ApiClient(string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");

            _baseUrl = basePath;
            _disposeClient = true;
            _httpClientHandler = new HttpClientHandler();
            _httpClient = new HttpClient(_httpClientHandler, true);
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" />
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <remarks>
        ///     Some configuration settings will not be applied without passing an HttpClientHandler.
        ///     The features affected are: Proxy settings.
        /// </remarks>
        public ApiClient(HttpClient client, string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");

            _baseUrl = basePath;
            _httpClient = client ?? throw new ArgumentNullException(nameof(client));
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" />.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An instance of HttpClientHandler that is used by HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public ApiClient(HttpClient client, HttpClientHandler handler, string basePath)
        {
            if (string.IsNullOrEmpty(basePath))
                throw new ArgumentException("basePath cannot be empty");

            _baseUrl = basePath;
            _httpClient = client ?? throw new ArgumentNullException(nameof(client));
            _httpClientHandler = handler ?? throw new ArgumentNullException(nameof(handler));
        }

        /// <summary>
        ///     Specifies the settings on a <see cref="JsonSerializer" /> object.
        ///     These settings can be adjusted to accomodate custom serialization rules.
        /// </summary>
        public JsonSerializerSettings SerializerSettings { get; set; } = new JsonSerializerSettings
        {
            // OpenAPI generated types generally hide default constructors.
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
            ContractResolver = new DefaultContractResolver
            {
                NamingStrategy = new CamelCaseNamingStrategy
                {
                    OverrideSpecifiedNames = false
                }
            },
            DateFormatString = "yyyy-MM-ddTHH:mm:ss.fffzzzz"
        };

        /// <summary>
        ///     Make a HTTP GET request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP POST request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP PUT request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP DELETE request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP HEAD request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP OPTION request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Make a HTTP PATCH request (async).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options,
            IReadableConfiguration configuration, CancellationToken cancellationToken = default)
        {
            return ExecAsync<T>(NewRequest(new HttpMethod("PATCH"), path, options, configuration), configuration,
                cancellationToken);
        }

        /// <summary>
        ///     Disposes HttpClient if it exists.
        /// </summary>
        public void Dispose()
        {
            if (_disposeClient)
                _httpClient.Dispose();
        }

        /// <summary>
        ///     Make a HTTP GET request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Get, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP POST request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Post, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP PUT request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Put, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP DELETE request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Delete, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP HEAD request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Head, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP OPTION request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(HttpMethod.Options, path, options, configuration), configuration);
        }

        /// <summary>
        ///     Make a HTTP PATCH request (synchronous).
        /// </summary>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>A Task containing ApiResponse</returns>
        public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration)
        {
            return Exec<T>(NewRequest(new HttpMethod("PATCH"), path, options, configuration), configuration);
        }

        /// Prepares multipart/form-data content
        private HttpContent PrepareMultipartFormDataContent(RequestOptions options)
        {
            var boundary = "---------" + Guid.NewGuid().ToString().ToUpperInvariant();
            var multipartContent = new MultipartFormDataContent(boundary);
            foreach (var formParameter in options.FormParameters)
                multipartContent.Add(new StringContent(formParameter.Value), formParameter.Key);

            if (options.FileParameters != null && options.FileParameters.Count > 0)
                foreach (var fileParam in options.FileParameters)
                {
                    var fileStreamName = fileParam.Value is FileStream fileStream
                        ? Path.GetFileName(fileStream.Name)
                        : null;
                    var content = new StreamContent(fileParam.Value);
                    content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
                    multipartContent.Add(content, fileParam.Key,
                        fileStreamName ?? "no_file_name_provided");
                }

            return multipartContent;
        }

        /// <summary>
        ///     Provides all logic for constructing a new HttpRequestMessage.
        ///     At this point, all information for querying the service is known. Here, it is simply
        ///     mapped into the a HttpRequestMessage.
        /// </summary>
        /// <param name="method">The http verb.</param>
        /// <param name="path">The target path (or resource).</param>
        /// <param name="options">The additional request options.</param>
        /// <param name="configuration">A per-request configuration object.</param>
        /// <returns>[private] A new HttpRequestMessage instance.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        private HttpRequestMessage NewRequest(
            HttpMethod method,
            string path,
            RequestOptions options,
            IReadableConfiguration configuration)
        {
            if (path == null)
                throw new ArgumentNullException(nameof(path));

            if (options == null)
                throw new ArgumentNullException(nameof(options));

            if (configuration == null)
                throw new ArgumentNullException(nameof(configuration));

            var builder = new WebRequestPathBuilder(_baseUrl, path);

            builder.AddPathParameters(options.PathParameters);

            builder.AddQueryParameters(options.QueryParameters);

            var request = new HttpRequestMessage(method, builder.GetFullUri());

            if (configuration.UserAgent != null)
                request.Headers.TryAddWithoutValidation("User-Agent", configuration.UserAgent);

            if (configuration.DefaultHeaders != null)
                foreach (var headerParam in configuration.DefaultHeaders)
                    request.Headers.Add(headerParam.Key, headerParam.Value);

            if (options.HeaderParameters != null)
                foreach (var headerParam in options.HeaderParameters)
                foreach (var value in headerParam.Value)
                    // Todo make content headers actually content headers
                    request.Headers.TryAddWithoutValidation(headerParam.Key, value);

            string contentType = null;
            if (options.HeaderParameters != null && options.HeaderParameters.ContainsKey("Content-Type"))
            {
                var contentTypes = options.HeaderParameters["Content-Type"];
                contentType = contentTypes.FirstOrDefault();
            }

            if (contentType == "multipart/form-data")
            {
                request.Content = PrepareMultipartFormDataContent(options);
            }
            else if (contentType == "application/x-www-form-urlencoded")
            {
                request.Content = new FormUrlEncodedContent(options.FormParameters);
            }
            else
            {
                if (options.Data != null)
                {
                    if (options.Data is FileParameter fp)
                    {
                        contentType = contentType ?? "application/octet-stream";

                        var streamContent = new StreamContent(fp.Content);
                        streamContent.Headers.ContentType = new MediaTypeHeaderValue(contentType);
                        request.Content = streamContent;
                    }
                    else
                    {
                        var serializer = new CustomJsonCodec(SerializerSettings, configuration);
                        request.Content = new StringContent(serializer.Serialize(options.Data), new UTF8Encoding(),
                            "application/json");
                    }
                }
            }

            return request;
        }

        private async Task<ApiResponse<T>> ToApiResponseAsync<T>(HttpResponseMessage response, object responseData,
            Uri uri)
        {
            var result = (T)responseData;
            var rawContent = response.Content.ToString();
            if (!response.IsSuccessStatusCode)
                rawContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);

            var transformed =
                new ApiResponse<T>(response.StatusCode, new Multimap<string, string>(), result, rawContent)
                {
                    ErrorText = response.ReasonPhrase
                };

            // process response headers, e.g. Access-Control-Allow-Methods
            if (response.Headers != null)
                foreach (var responseHeader in response.Headers)
                    transformed.Headers.Add(responseHeader.Key, ClientUtils.ParameterToString(responseHeader.Value));

            // process response content headers, e.g. Content-Type
            if (response.Content.Headers != null)
                foreach (var responseHeader in response.Content.Headers)
                    transformed.Headers.Add(responseHeader.Key, ClientUtils.ParameterToString(responseHeader.Value));

            return transformed;
        }

        private ApiResponse<T> Exec<T>(HttpRequestMessage req, IReadableConfiguration configuration)
        {
            return ExecAsync<T>(req, configuration).GetAwaiter().GetResult();
        }

        private async Task<ApiResponse<T>> ExecAsync<T>(HttpRequestMessage req,
            IReadableConfiguration configuration,
            CancellationToken cancellationToken = default)
        {
            var deserializer = new CustomJsonCodec(SerializerSettings, configuration);

            CancellationTokenSource timeoutCancellationTokenSource = null;
            var finalToken = cancellationToken;

            try
            {
                if (configuration.Timeout > 0)
                {
                    timeoutCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                    timeoutCancellationTokenSource.CancelAfter(configuration.Timeout);
                    finalToken = timeoutCancellationTokenSource.Token;
                }

                if (configuration.Proxy != null)
                {
                    if (_httpClientHandler == null)
                        throw new InvalidOperationException(
                            "Configuration `Proxy` not supported when the client is explicitly created without an HttpClientHandler, use the proper constructor.");
                    _httpClientHandler.Proxy = configuration.Proxy;
                }

                HttpResponseMessage response;
                if (RetryConfiguration.AsyncRetryPolicy != null)
                {
                    var policy = RetryConfiguration.AsyncRetryPolicy;
                    var policyResult = await policy
                        .ExecuteAndCaptureAsync(() => _httpClient.SendAsync(req, finalToken))
                        .ConfigureAwait(false);
                    response = policyResult.Outcome == OutcomeType.Successful
                        ? policyResult.Result
                        : new HttpResponseMessage
                        {
                            ReasonPhrase = policyResult.FinalException.ToString(),
                            RequestMessage = req
                        };
                }
                else
                {
                    response = await _httpClient.SendAsync(req, finalToken).ConfigureAwait(false);
                }

                object responseData = await deserializer.DeserializeAsync<T>(response).ConfigureAwait(false);

                // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
                if (typeof(AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
                    responseData = (T)typeof(T).GetMethod("FromJson")?.Invoke(null, new object[] { response.Content });
                else if (typeof(T).Name == "Stream") // for binary response
                    responseData = (T)(object)await response.Content.ReadAsStreamAsync().ConfigureAwait(false);

                var result = await ToApiResponseAsync<T>(response, responseData, req.RequestUri).ConfigureAwait(false);

                return result;
            }
            finally
            {
                timeoutCancellationTokenSource?.Dispose();
            }
        }
    }
}